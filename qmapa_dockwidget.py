# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QMapaDockWidget
                                 A QGIS plugin
 Wtyczka do programu QGIS służąca do wizualizacji mapy zasadniczej z plików
 GML obejmujących zbiory danych EGiB, GESUT i BDOT500 zgodnie ze standardami
 opublikowanymi w rozporządzeniu Ministra Rozwoju, Pracy i Technologii z dnia
 23 lipca 2021 r. w sprawie bazy danych obiektów topograficznych oraz mapy
 zasadniczej.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-04-07
        git sha              : $Format:%H$
        copyright            : (C) 2022 by  
        email                :  
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from datetime import datetime
import webbrowser

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import Qt, QVariant, QDateTime, QSize, pyqtSignal, pyqtSlot
from qgis.PyQt.QtWidgets import QFileDialog, QPushButton, QDialog
from qgis.PyQt.QtCore import pyqtSignal, pyqtSlot, QVariant, QDateTime
from qgis.PyQt.QtWidgets import QFileDialog, QMessageBox
from qgis.utils import iface
from qgis.core import *

# import z folderu src
from .src.create_relations import CreateRelations
from .src.gml_modify import GmlModify
from .src.layer_order import set_new_order
from .src.load_gpkg import load_gpkg
from .src.qmapa_main import Main
from .src.config import correct_layers
from .src.scrap_version import *
from .src.config import correct_layers
from .src.express_yourself import ExpressYourself
from .src.fill_with_color import fill, open_fill_xlsm, open_fill_xlsm_loc
from openpyxl import Workbook
from .src.create_report_file import report


from osgeo_utils.samples import ogr2ogr


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui', 'qmapa_dockwidget_base.ui'))

PLUGIN_DIRECTORY = os.path.dirname(os.path.realpath(__file__))

FILL_PARAMETERS = os.path.join(PLUGIN_DIRECTORY, 'fill', 'QMapa_wypelnieniaObszarow_2022-10-26.xlsm')

class QMapaDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(QMapaDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.signal_of_import = False
        self.setupUi(self)

        self.cmbStylization.addItems(Main().getStylizations(omit_special=True))

        # sprawdzenie wersji programu
        self.check_version()

        self.progressBar.hide()

        self.rel_times = 0

        self.set_red_labels()

        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Pierwsze',
                                                     [0, 0, 0])
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Modyfikowane',
                                                     [0, 0, 0])
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Archiwalne',
                                                     [0, 0, 0])
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Zamkniete',
                                                     [0, 0, 0])
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Wczesniejsze',
                                                     [0, 0, 0])

        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'DateCompare', 0)

        iface.mapCanvas().refreshAllLayers()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def check_version(self):
        """sprawdzenie czy zainstalowana wersja wtyczki jest aktualna"""
        try:
            URL = 'https://github.com/geoxyIT/QMapa/blob/main/metadata.txt'
            local_path = (os.path.join(os.path.dirname(__file__), 'metadata.txt'))
            hub_ver = reg_ver(get_hub_ver(URL))
            local_ver = reg_ver(get_local_ver(local_path))
            compare_versions(self.lbVersion, hub_ver, local_ver)
        except Exception as e:
            print('Blad sprawdzania aktualnosci wersji')
            print(e)
            print('Nawiaz polaczenie z internetem')

    @pyqtSlot()
    def on_pbLogo_clicked(self):
        """Przycisk wywolania strony po nacisnieciu Logo GEOXY"""
        webbrowser.open('http://www.geoxy.pl/')
        print(QgsProject.instance().clear())

    def paths(self, gml_path):
        """utworzenie sciezek plikow importu i raportu, sprawdzenie czy juz istnieja i czy jest do nich dostep, zapytanie czy nadpisac"""

        path, ext = os.path.splitext(gml_path)
        mod_gml_path = os.path.join(os.path.dirname(path), os.path.basename(path) + '_mod' + ext)
        gpkg_path = os.path.join(os.path.dirname(path), os.path.basename(path) + '.gpkg')
        report_path = os.path.join(os.path.dirname(path), os.path.basename(path) + '.xlsx')

        # slownik zawierajacy liste istniejacych juz plikow importu:
        dict_existing_files = {}
        if os.path.exists(mod_gml_path):
            dict_existing_files['Zmodyfikowany gml'] = mod_gml_path
        if os.path.exists(gpkg_path):
            dict_existing_files['Plik GeoPackage'] = gpkg_path
        if os.path.exists(report_path):
            dict_existing_files['Plik raportu'] = report_path

        # zapytanie czy nadpisac, sprawdzenie dostepu:
        if len(dict_existing_files)>0:
            # dobranie odpowiednich slow w zalezosci od liczy pojedynczej / mnogiej
            if len(dict_existing_files) == 1:
                info_1 = 'Plik'
                info_2 = 'istnieje'
                info_3 = 'go'
            else:
                info_1 = 'Pliki'
                info_2 = 'istnieją'
                info_3 = 'je'

            existing_file_names = []
            for name_key, path  in dict_existing_files.items():
                existing_file_names.append(name_key + ": \n" + path)

            # zapytanie czy nadpisac
            allow_override_reply = QMessageBox.question(iface.mainWindow(), 'Nadpisać?',
                                         ("{} importu już {}, czy chesz {} nadpisać? \n\n{}".format(info_1, info_2, info_3, ', \n\n'.join(existing_file_names))), QMessageBox.Yes, QMessageBox.No)


            if allow_override_reply == QMessageBox.Yes:
                for name_key, path in dict_existing_files.items():
                    # sprawdzenie dostepu poprzez probe usuniecia pliku
                    try:
                        os.remove(path)
                    except:
                        iface.messageBar().pushMessage("import nie został wykonany: ", "brak dostępu do pliku " + path,
                                                       level=2, duration=0)
                        QMessageBox.critical(iface.mainWindow(), 'Błąd: brak dostępu do pliku',
                                         'Brak dostępu do pliku, sprawdż czy plik nie jest używany przez inny program. \n' + path, buttons=QMessageBox.Ok)


                        print('nie można otworzyć pliku')
                        mod_gml_path = ''
                        gpkg_path = ''
                        report_path = ''
                        break
            else:
                iface.messageBar().pushMessage("import nie został wykonany: ", "nie zezwolono na nadpisanie", level = Qgis.Info, duration = 0)
                mod_gml_path = ''
                gpkg_path = ''
                report_path = ''

        return mod_gml_path, gpkg_path, report_path

    def on_pbImport_pressed(self):
        """Zaimportowanie pliku GML z konwersją do GPKG oraz nadaniem grup warstw"""
        name, ext = QFileDialog.getOpenFileName(self, caption='Wybierz wejściowy plik GML',
                                                filter='gml (*.gml)')

        if name != '':
            mod_gml_path, gpkg_path, report_path = self.paths(name)  # pobranie sciezek importu
            if mod_gml_path != '' and gpkg_path != '' and report_path != '':
                start_2 = datetime.now()

                self.signal_of_import = True
                self.progressBar.show()
                self.progressBar.setValue(1)
                self.gml_mod = GmlModify(name, mod_gml_path)
                self.gml_mod.run()  # przerobienie pliku gml i zapisanie do nowego pliku
                self.progressBar.setValue(10)
                print('czas 10%:', datetime.now() - start_2)

                # utworzenie gpkg z gml
                ogr2ogr.main(["", "-f", "GPKG", gpkg_path, mod_gml_path])
                self.progressBar.setValue(20)
                print('czas 20%:', datetime.now() - start_2)
                load_gpkg(gpkg_path)
                self.progressBar.setValue(30)
                print('czas 30%:', datetime.now() - start_2)
                self.vec_layers_list, gr_dict = Main().create_groups(gpkg_path)
                self.vec_layers_list = Main().checkLayers(self.vec_layers_list)

                order_list_new = correct_layers  # lista warstw zgodna z rozpo i w dobrej kolejnosci prezentowania

                # ustalenie nowej kolejnosci
                set_new_order(order_list_new)
                self.progressBar.setValue(40)
                print('czas 40%:', datetime.now() - start_2)

                # utworzenie raportu
                counting_dict = Main().generateReport(gr_dict)
                report().run(counting_dict, name, report_path)
                self.progressBar.setValue(50)
                print('czas 50%:', datetime.now() - start_2)

                # nadanie zlaczen
                self.set_joins(self.vec_layers_list)
                self.progressBar.setValue(60)
                print('czas 60%:', datetime.now() - start_2)

                # usuniecie pliku
                try:
                    os.remove(mod_gml_path)
                except:
                    print("Problem z usunieciem pliku modyfikowanego gml")
                self.progressBar.setValue(70)
                print('czas 70%:', datetime.now() - start_2)

                # nadanie stylizacji
                current_style = self.cmbStylization.currentText()
                #Main().setStyling(self.vec_layers_list, current_style)
                self.back_to_qml_symb()
                self.progressBar.setValue(80)
                print('czas 80%:', datetime.now() - start_2)

                #self.set_labels(self.vec_layers_list)
                '''self.wyswWg()  # sprawdzenie i nadanie wyswietlania wersji, statusu'''
                self.disp_wers() #sprawdzenie i nadanie wyswietlania wersji
                self.progressBar.setValue(90)
                print('czas 90%:', datetime.now() - start_2)

                # obliczenie kreskowania dla skarp, sciany, schodow i wstawienie geometrii do atrybutow
                scales = ['500', '1000']
                nr = 0

                start_point_layer_id = False
                end_point_layer_id = False
                ot_polyline_layer_id = False
                egb_polyline_layer_id = False
                for ll in self.vec_layers_list:
                    if 'poczatekgoryskarpy' in ll.name().lower():
                        start_point_layer_id = ll.id()
                    elif 'koniecgoryskarpy' in ll.name().lower():
                        end_point_layer_id = ll.id()
                    elif 'ot_poliliniakierunkowa' in ll.name().lower():
                        ot_polyline_layer_id =  ll.id()
                    elif 'egb_poliliniakierunkowa' in ll.name().lower():
                        egb_polyline_layer_id = ll.id()

                for sc in scales:
                    self.progressBar.setValue(90 + int((nr/len(scales))*10))
                    print('czas ' + str(90 + int((nr/len(scales))*10)) + '%:', datetime.now() - start_2)
                    nr += 1
                    for lay in self.vec_layers_list:
                        if 'skarpa' in lay.name().lower() and start_point_layer_id and end_point_layer_id:
                            Main().calculate_hatching(lay, 'skarpa', sc, [start_point_layer_id, end_point_layer_id])
                        elif 'ot_obiekttrwalezwiazany' in lay.name().lower() and ot_polyline_layer_id:
                            Main().calculate_hatching(lay, 'schody', sc, ot_polyline_layer_id)
                        elif 'egb_obiekttrwalezwiazany' in lay.name().lower() and egb_polyline_layer_id:
                            Main().calculate_hatching(lay, 'schody', sc, egb_polyline_layer_id)
                        elif 'budowle' in lay.name().lower() and ot_polyline_layer_id:
                            Main().calculate_hatching(lay, 'sciana', sc, ot_polyline_layer_id)
                        elif 'wody' in lay.name().lower()  and start_point_layer_id and end_point_layer_id:
                            Main().calculate_hatching(lay, 'wody', sc, [start_point_layer_id, end_point_layer_id])
                        elif 'komunikacja' in lay.name().lower() and ot_polyline_layer_id:
                            Main().calculate_hatching(lay, 'schody', sc, ot_polyline_layer_id)

                        if sc == '500':
                            if 'ges_rzedna' in lay.name().lower() and sc == '500':
                                Main().remove_all_joins(lay)
                                Main().calculate_colors(lay, 'color')

                        if 'etykieta' not in lay.name().lower() and 'prezentacja' not in lay.name().lower() and sc == '1000':
                            Main().add_obligatory_fields(lay)
                self.progressBar.setValue(100)
                print('czas 100%:', datetime.now() - start_2)
                self.progressBar.hide()

                iface.messageBar().pushMessage("raport z importu", '<a href="file:///' + report_path + '">' + report_path + '</a>', level = Qgis.Success, duration = 0)

                self.signal_of_import = False

    def on_cmbStylization_currentTextChanged(self):
        """ustaw stylizację wybraną w comboboxie"""
        self.back_to_qml_symb()
        self.disp_wers()

    def set_joins(self, vec_layers_list):
        """nadawanie joinow podczas importu pliku"""
        joining_dict = {'GES_Rzedna': {'GES_InneUrzadzeniaTowarzyszace': ['relacja', 'lokalnyId', ['rodzajSieci']],
                                       'GES_UrzadzeniaTowarzyszczaceLiniowe': ['relacja', 'lokalnyId', ['rodzajSieci']],
                                       'GES_UrzadzeniaTowarzyszaceLiniowe': ['relacja', 'lokalnyId', ['rodzajSieci']],
                                       'GES_PrzewodWodociagowy': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_PrzewodKanalizacyjny': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_PrzewodElektroenergetyczny': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_PrzewodGazowy': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_PrzewodCieplowniczy': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_PrzewodTelekomunikacyjny': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_PrzewodSpecjalny': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_PrzewodNiezidentyfikowany': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_UrzadzeniaSiecWodociagowa': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_UrzadzeniaSiecKanalizacyjna': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_UrzadzeniaSiecElektroenergetyczna': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_UrzadzeniaSiecGazowa': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_UrzadzeniaSiecCieplownicza': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_UrzadzeniaSiecTelekomunikacyjna': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_UrzadzeniaTechniczneSieciSpecjalnej': ['relacja', 'lokalnyId', ['zrodlo']],
                                       'GES_UrzadzenieNiezidentyfikowane': ['relacja', 'lokalnyId', ['zrodlo']]
                                       },
                        'OT_etykieta': {'OT_odnosnik': ['gml_id', 'gml_id', ['x', 'y']],
                                        'OT_BudynekNiewykazanyWEGIB': ['obiektPrzedstawiany', 'gml_id', []],
                                        'OT_BlokBudynku': ['obiektPrzedstawiany', 'gml_id', []],
                                        'OT_ObiektTrwaleZwiazanyZBudynkami': ['obiektPrzedstawiany', 'gml_id', []],
                                        'OT_Budowle': ['obiektPrzedstawiany', 'gml_id', []],
                                        'OT_Komunikacja': ['obiektPrzedstawiany', 'gml_id', []],
                                        'OT_SportIRekreacja': ['obiektPrzedstawiany', 'gml_id', []],
                                        'OT_ZagospodarowanieTerenu': ['obiektPrzedstawiany', 'gml_id', []],
                                        'OT_Wody': ['obiektPrzedstawiany', 'gml_id', []],
                                        'OT_Rzedna': ['obiektPrzedstawiany', 'gml_id', []]},
                        'EGB_etykieta': {'EGB_odnosnik': ['gml_id', 'gml_id', ['x', 'y']],
                                         'EGB_JednostkaEwidencyjna': ['obiektPrzedstawiany', 'gml_id', []],
                                         'EGB_ObrebEwidencyjny': ['obiektPrzedstawiany', 'gml_id', []],
                                         'EGB_DzialkaEwidencyjna': ['obiektPrzedstawiany', 'gml_id', []],
                                         'EGB_PunktGraniczny': ['obiektPrzedstawiany', 'gml_id', []],
                                         'EGB_Budynek': ['obiektPrzedstawiany', 'gml_id', []],
                                         'EGB_BlokBudynku': ['obiektPrzedstawiany', 'gml_id', []],
                                         'EGB_ObiektTrwaleZwiazanyZBudynkiem': ['obiektPrzedstawiany', 'gml_id', []],
                                         'EGB_KonturUzytkuGruntowego': ['obiektPrzedstawiany', 'gml_id', []],
                                         'EGB_KonturKlasyfikacyjny': ['obiektPrzedstawiany', 'gml_id', []]},

                        'GES_etykieta': {'GES_odnosnik': ['gml_id', 'gml_id', ['x', 'y']],
                                         'GES_InneUrzadzeniaTowarzyszace': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaTowarzyszczaceLiniowe': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaTowarzyszaceLiniowe': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_PrzewodWodociagowy': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_PrzewodKanalizacyjny': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_PrzewodElektroenergetyczny': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_PrzewodGazowy': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_PrzewodCieplowniczy': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_PrzewodTelekomunikacyjny': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_PrzewodSpecjalny': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_PrzewodNiezidentyfikowany': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaSiecWodociagowa': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaSiecKanalizacyjna': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaSiecElektroenergetyczna': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaSiecGazowa': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaSiecCieplownicza': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaSiecTelekomunikacyjna': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_UrzadzeniaTechniczneSieciSpecjalnej': ['obiektPrzedstawiany', 'gml_id',
                                                                                     []],
                                         'GES_UrzadzenieNiezidentyfikowane': ['obiektPrzedstawiany', 'gml_id', []],
                                         'GES_Rzedna': ['obiektPrzedstawiany', 'gml_id', []]},
                        'GES_UrzadzeniaSiecWodociagowa': {
                            'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'GES_UrzadzeniaSiecKanalizacyjna': {
                            'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'GES_UrzadzeniaSiecElektroenergetyczna': {
                            'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'GES_UrzadzeniaSiecGazowa': {'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'GES_UrzadzeniaSiecCieplownicza': {
                            'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'GES_UrzadzeniaSiecTelekomunikacyjna': {
                            'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'GES_UrzadzeniaTechniczneSieciSpecjalnej': {
                            'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'GES_UrzadzenieNiezidentyfikowane': {
                            'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'GES_InneUrzadzeniaTowarzyszace': {
                            'GES_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'OT_Budowle': {'OT_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'OT_ZagospodarowanieTerenu': {'OT_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'OT_Wody': {'OT_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'OT_ObiektTrwaleZwiazanyZBudynkami': {
                            'OT_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]},
                        'EGB_ObiektTrwaleZwiazanyZBudynkiem': {
                            'OT_PrezentacjaGraficzna': ['gml_id', 'obiektPrzedstawiany', []]}
                        }

        # layers = self.getLayers()
        # tworzenie zlaczen warstw
        for layer in vec_layers_list:
            layer_name = layer.name()
            if layer_name in joining_dict:
                dict_main_layer = joining_dict[layer_name]
                for layer_joining in vec_layers_list:
                    layer_joining_name = layer_joining.name()
                    if layer_joining_name in dict_main_layer:
                        joining_info = dict_main_layer[layer_joining_name]
                        key_main = joining_info[0]
                        key_joining = joining_info[1]
                        fields_list = joining_info[2]
                        prefix = layer_joining_name + '_' + str(layer_joining.geometryType()) + '_'
                        QgsProject.instance().addMapLayer(layer)
                        QgsProject.instance().addMapLayer(layer_joining)
                        joinObject = QgsVectorLayerJoinInfo()
                        joinObject.setJoinFieldNamesBlockList(
                            ['prezentacja_etykiety', 'fid', 'przestrzenNazw', 'wersjaId', 'numerOperatu', 'wladajacy'])
                        joinObject.setCascadedDelete(False)
                        joinObject.setDynamicFormEnabled(False)
                        joinObject.setEditable(False)
                        joinObject.setUpsertOnEdit(False)
                        joinObject.setJoinFieldName(key_joining)
                        joinObject.setTargetFieldName(key_main)
                        if len(fields_list) > 0:
                            joinObject.setJoinFieldNamesSubset(fields_list)
                        joinObject.setPrefix(prefix)
                        joinObject.setJoinLayerId(layer_joining.id())
                        joinObject.setUsingMemoryCache(True)
                        joinObject.setJoinLayer(layer_joining)
                        layer.addJoin(joinObject)

        # dodawanie pol
        for layer in vec_layers_list:
            fields_list_obj = layer.fields().toList()
            fields_list = []
            if layer.name() == 'GES_odnosnik' or layer.name() == 'EGB_odnosnik' or layer.name() == 'OT_odnosnik':
                for field in fields_list_obj:
                    fields_list.append(field.name())
                if 'x' not in fields_list:
                    field = QgsField('x', QVariant.Double)
                    layer.addExpressionField('$x', field)
                if 'y' not in fields_list:
                    field2 = QgsField('y', QVariant.Double)
                    layer.addExpressionField('$y', field2)
        iface.mapCanvas().refreshAllLayers()

    def on_cmbReda_currentTextChanged(self):
        # self.set_labels(self.getLayers())
        self.set_red_labels()

    def set_red_labels(self):
        if 'auto' in self.cmbReda.currentText().lower():
            auto = 1
            karto = 0
        elif 'karto' in self.cmbReda.currentText().lower():
            auto = 0
            karto = 1
        else:
            auto = 0
            karto = 0
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Auto', auto)
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Karto', karto)

        iface.mapCanvas().refreshAllLayers()

    def getLayersByName(self, name):
        layers = self.getLayers()
        sk_layers = []
        for layer in layers:
            if name in layer.name().lower():
                sk_layers.append(layer)
        return sk_layers

    def getLayers(self):
        """pobierz listę warstw do symbolizacji i labelingu
        --pobieranie warstw w oparciu o warstwy w rozporzadzeniu"""
        lays = iface.mapCanvas().layers()

        layers = Main().checkLayers(lays)

        return layers

    def on_chbShowPierwsze_stateChanged(self):
        self.disp_settings()

    def on_chbShowModyfikowane_stateChanged(self):
        self.disp_settings()

    def on_chbShowArchiwalne_stateChanged(self):
        self.disp_settings()

    def on_chbShowZamkniete_stateChanged(self):
        self.disp_settings()

    def on_chbShowWczesniejsze_stateChanged(self):
        self.disp_settings()

    def on_chbColorPierwsze_stateChanged(self):
        self.disp_settings()

    def on_chbColorModyfikowane_stateChanged(self):
        self.disp_settings()

    def on_chbColorArchiwalne_stateChanged(self):
        self.disp_settings()

    def on_chbColorZamkniete_stateChanged(self):
        self.disp_settings()

    def on_chbColorWczesniejsze_stateChanged(self):
        self.disp_settings()

    def on_colPierwsze_stateChanged(self):
        self.disp_settings()

    def on_colModyfikowane_stateChanged(self):
        self.disp_settings()

    def on_colArchiwalne_stateChanged(self):
        self.disp_settings()

    def on_colZamkniete_stateChanged(self):
        self.disp_settings()

    def on_colWczesniejsze_stateChanged(self):
        self.disp_settings()

    def on_colPierwsze_colorChanged(self):
        self.disp_settings()

    def on_colModyfikowane_colorChanged(self):
        self.disp_settings()

    def on_colArchiwalne_colorChanged(self):
        self.disp_settings()

    def on_colZamkniete_colorChanged(self):
        self.disp_settings()

    def on_colWczesniejsze_colorChanged(self):
        self.disp_settings()

    def on_chbZnacznik_stateChanged(self):
        self.disp_settings()

    def on_dteZnacznik_valueChanged(self):
        self.disp_settings()

    def on_gbShowWers_toggled(self, on):

        self.disp_wers()

    def back_to_qml_symb(self):
        """Wczytanie stylizacji QML"""
        current_style = self.cmbStylization.currentText()
        Main().setStyling(self.list_or_canvas(self.signal_of_import), current_style)
        expression = ExpressYourself('', '')
        expression.set_label_expression(self.list_or_canvas(self.signal_of_import), False)
        # self.set_labels(self.getLayers())

    def disp_wers(self):
        """ustawienie wyswietlania/niewyswietlania po wersjach"""
        on = self.gbShowWers.isChecked()
        self.back_to_qml_symb()
        if on:
            self.disp_settings()
            expr_show = " with_variable( 'show', pokaz_wersje(@DateCompare, @Pierwsze, @Modyfikowane, @Archiwalne, @Zamkniete, @Wczesniejsze, concat(" + '"startObiekt"' + ", ''),concat(" + '"startWersjaObiekt"' + ", ''),concat(" + '"koniecObiekt"' + ", ''),concat(" + '"koniecWersjaObiekt"' + ", '')),  if( var('show') != 'default', var('show'), 1111))"
            expr_color = " with_variable( 'color', kolor_wersji(@DateCompare, @Pierwsze, @Modyfikowane, @Archiwalne, @Zamkniete, @Wczesniejsze, concat(" + '"startObiekt"' + ", ''),concat(" + '"startWersjaObiekt"' + ", ''),concat(" + '"koniecObiekt"' + ", ''),concat(" + '"koniecWersjaObiekt"' + ", '')),  if( var('color'), var('color'), 1111))"

            expression = ExpressYourself(expr_color, expr_show)
            expression.set_symbol_expression(self.list_or_canvas(self.signal_of_import))
            expression.set_label_expression(self.list_or_canvas(self.signal_of_import))
        else:
            # powrot do pierwotnej stylizacji z QML
            #self.back_to_qml_symb()
            pass

    def list_or_canvas(self, signal_of_import):
        """Zaleznie od sygnalu, pobierane sa warstwy albo z listy warstw wektorowych
            albo z metody getLayers. Ma to za zadanie pozyskac odpowiednie warstwy podczas
            importu. Aby zostala nadana symbolizacja wg. wersji.
        """
        if signal_of_import is True:
            layers = self.vec_layers_list
        else:
            layers = self.getLayers()
        return layers

    def disp_settings(self):
        """ustawienia dotyczace wyswietlania po wersjach:
        pobranie ustawien z okna wtyczki i zapisanie do zmiennych w projekcie
        obsluga aktywowania opcji w oknie wtyczki"""

        # todo : opisac
        #
        # Pierwsze
        if self.chbShowPierwsze.isChecked():
            self.chbColorPierwsze.setEnabled(True)
            vis_Pierwsze = True
            if self.chbColorPierwsze.isChecked() is True:
                self.colPierwsze.setEnabled(True)
                # color_Pierwsze = "'" + ','.join([str(x) for x in self.colPierwsze.color().getRgb()]) + "'"
                color_Pierwsze = ','.join([str(x) for x in self.colPierwsze.color().getRgb()])
                set_color_Pierwsze = True
            else:
                self.colPierwsze.setEnabled(False)
                set_color_Pierwsze = False
                color_Pierwsze = 0
        else:
            set_color_Pierwsze = False
            vis_Pierwsze = False
            color_Pierwsze = 0
            self.chbColorPierwsze.setEnabled(False)
            self.colPierwsze.setEnabled(False)

        # Modyfikowane
        if self.chbShowModyfikowane.isChecked():
            self.chbColorModyfikowane.setEnabled(True)
            vis_Modyfikowane = True
            if self.chbColorModyfikowane.isChecked() is True:
                self.colModyfikowane.setEnabled(True)
                # color_Modyfikowane = "'" + ','.join([str(x) for x in self.colModyfikowane.color().getRgb()]) + "'"
                color_Modyfikowane = ','.join([str(x) for x in self.colModyfikowane.color().getRgb()])
                set_color_Modyfikowane = True
            else:
                self.colModyfikowane.setEnabled(False)
                set_color_Modyfikowane = False
                color_Modyfikowane = 0
        else:
            set_color_Modyfikowane = False
            vis_Modyfikowane = False
            color_Modyfikowane = 0
            self.chbColorModyfikowane.setEnabled(False)
            self.colModyfikowane.setEnabled(False)

        # Archiwalne
        if self.chbShowArchiwalne.isChecked():
            self.chbColorArchiwalne.setEnabled(True)
            vis_Archiwalne = True
            if self.chbColorArchiwalne.isChecked() is True:
                self.colArchiwalne.setEnabled(True)
                # color_Archiwalne = "'" + ','.join([str(x) for x in self.colArchiwalne.color().getRgb()]) + "'"
                color_Archiwalne = ','.join([str(x) for x in self.colArchiwalne.color().getRgb()])
                set_color_Archiwalne = True
            else:
                self.colArchiwalne.setEnabled(False)
                set_color_Archiwalne = False
                color_Archiwalne = 0
        else:
            set_color_Archiwalne = False
            vis_Archiwalne = False
            color_Archiwalne = 0
            self.chbColorArchiwalne.setEnabled(False)
            self.colArchiwalne.setEnabled(False)

        # Zamkniete
        if self.chbShowZamkniete.isChecked():
            self.chbColorZamkniete.setEnabled(True)
            vis_Zamkniete = True
            if self.chbColorZamkniete.isChecked() is True:
                self.colZamkniete.setEnabled(True)
                # color_Zamkniete = "'" + ','.join([str(x) for x in self.colZamkniete.color().getRgb()]) + "'"
                color_Zamkniete = ','.join([str(x) for x in self.colZamkniete.color().getRgb()])
                set_color_Zamkniete = True
            else:
                self.colZamkniete.setEnabled(False)
                set_color_Zamkniete = False
                color_Zamkniete = 0
        else:
            set_color_Zamkniete = False
            vis_Zamkniete = False
            color_Zamkniete = 0
            self.chbColorZamkniete.setEnabled(False)
            self.colZamkniete.setEnabled(False)

        # Znacznik czasu
        if self.chbZnacznik.isChecked():
            self.dteZnacznik.setEnabled(True)
            date_to_compare = self.dteZnacznik.dateTime()
            self.chbShowWczesniejsze.setEnabled(True)

            # Wczesniejsze
            if self.chbShowWczesniejsze.isChecked():
                self.chbColorWczesniejsze.setEnabled(True)
                vis_Wczesniejsze = True
                if self.chbColorWczesniejsze.isChecked() is True:
                    self.colWczesniejsze.setEnabled(True)
                    # color_Wczesniejsze = "'" + ','.join([str(x) for x in self.colWczesniejsze.color().getRgb()]) + "'"
                    color_Wczesniejsze = ','.join([str(x) for x in self.colWczesniejsze.color().getRgb()])
                    set_color_Wczesniejsze = True
                else:
                    self.colWczesniejsze.setEnabled(False)
                    set_color_Wczesniejsze = False
                    color_Wczesniejsze = 0
            else:
                set_color_Wczesniejsze = False
                vis_Wczesniejsze = False
                color_Wczesniejsze = 0
                self.chbColorWczesniejsze.setEnabled(False)
                self.colWczesniejsze.setEnabled(False)

        else:
            self.dteZnacznik.setEnabled(False)
            date_to_compare = 0

            # wczesniejsze cd
            self.chbShowWczesniejsze.setEnabled(False)
            set_color_Wczesniejsze = False
            vis_Wczesniejsze = False
            color_Wczesniejsze = 0
            self.chbColorWczesniejsze.setEnabled(False)
            self.colWczesniejsze.setEnabled(False)

        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Pierwsze',
                                                     [vis_Pierwsze, set_color_Pierwsze, color_Pierwsze])
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Modyfikowane',
                                                     [vis_Modyfikowane, set_color_Modyfikowane, color_Modyfikowane])
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Archiwalne',
                                                     [vis_Archiwalne, set_color_Archiwalne, color_Archiwalne])
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Zamkniete',
                                                     [vis_Zamkniete, set_color_Zamkniete, color_Zamkniete])
        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'Wczesniejsze',
                                                     [vis_Wczesniejsze, set_color_Wczesniejsze, color_Wczesniejsze])

        QgsExpressionContextUtils.setProjectVariable(QgsProject.instance(), 'DateCompare', date_to_compare)

        iface.mapCanvas().refreshAllLayers()

    def mousePressEvent(self, QMouseEvent):
        """Przejecie prawego przycisku pod wyswietlanie opcji fillowania"""
        if QMouseEvent.button() == Qt.RightButton:
            # pobranie aktualnej pozycji kursora w czasie klikniecia
            cursor = QtGui.QCursor()
            cur_pos = cursor.pos()

            current_scale = self.cmbStylization.currentText()

            self.right_click_dlg = QDialog()
            self.right_click_dlg.setWindowFlag(Qt.WindowContextHelpButtonHint, False)  # This removes it
            self.right_click_dlg.setFixedSize(QSize(220, 90))
            self.right_click_dlg.setWindowTitle("Okno wypełnień")

            # pobranie atrybutow odpowiadajacych za wielkosc okna
            # wykorzystane przy nadaniu wielkosci przyciskow
            window_width = self.right_click_dlg.frameGeometry().width()
            window_height = self.right_click_dlg.frameGeometry().height()

            # definicja przyciskow
            btn_fill = QPushButton(self.right_click_dlg)
            btn_fill.setAutoDefault(False)
            btn_fill.setText("Nadaj kolorystyke wypełnień")
            btn_fill.setFixedSize(QSize(window_width, 30))
            # powrot do stylizacji
            btn_fill.clicked.connect(self.back_to_qml_symb)
            btn_fill.clicked.connect(self.disp_wers)
            btn_fill.clicked.connect(lambda: fill(excel_path=FILL_PARAMETERS, scale=current_scale))
            btn_fill.clicked.connect(self.close_dialog)

            btn_fill_xlsm = QPushButton(self.right_click_dlg)
            btn_fill_xlsm.setAutoDefault(False)
            btn_fill_xlsm.setText("Otwórz plik xlsm z parametrami wypełnień")
            btn_fill_xlsm.move(0, 30)
            btn_fill_xlsm.setFixedSize(QSize(window_width, 30))
            btn_fill_xlsm.clicked.connect(lambda: open_fill_xlsm(path=FILL_PARAMETERS))
            btn_fill_xlsm.clicked.connect(self.close_dialog)

            btn_fill_loc = QPushButton(self.right_click_dlg)
            btn_fill_loc.setAutoDefault(False)
            btn_fill_loc.setText("Otwórz lokalizacje pliku wypełnień")
            btn_fill_loc.move(0, 60)
            btn_fill_loc.setFixedSize(QSize(window_width, 30))
            btn_fill_loc.clicked.connect(lambda: open_fill_xlsm_loc(path=os.path.join(PLUGIN_DIRECTORY, 'fill')))
            btn_fill_loc.clicked.connect(self.close_dialog)

            # przesuniecie okna do pozycji kursora
            self.right_click_dlg.move(cur_pos)
            self.right_click_dlg.show()

    def close_dialog(self):
        """Zamykanie okna dialogu po wywolaniu funkcji"""
        self.right_click_dlg.close()

